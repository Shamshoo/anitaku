{
  "id": "anitaku-provider",
  "name": "AniTaku (Streaming)",
  "description": "Online anime streaming provider for AniTaku (formerly GogoAnime) with a vast library of subbed and dubbed anime",
  "version": "1.0.0",
  "type": "online-streaming-provider",
  "manifestURI": "https://raw.githubusercontent.com/yourusername/anitaku-seanime-provider/main/manifest.json",
  "language": "javascript",
  "author": "Your Name",
  "meta": {
    "website": "https://anitaku.to"
  },
  "payload": "/// <reference path=\"./online-streaming-provider.d.ts\" />\n/// <reference path=\"./doc.d.ts\" />\n/// <reference path=\"./crypto.d.ts\" />\n\nclass Provider {\n  constructor() {\n    this.api = \"https://anitaku.to\";\n    this.ajaxUrl = \"https://ajax.gogo-load.com/ajax\";\n  }\n\n  getSettings() {\n    return {\n      episodeServers: [\"default\", \"vidstreaming\", \"streamsb\", \"doodstream\"],\n      supportsDub: true,\n    };\n  }\n\n  async search(query) {\n    console.log(\"Search query:\", query);\n    \n    try {\n      const response = await fetch(`${this.api}/search.html?keyword=${encodeURIComponent(query)}`);\n      console.log(\"Response status:\", response.status);\n      \n      const html = await response.text();\n      console.log(\"HTML length:\", html.length);\n      \n      const results = [];\n      \n      // Load the HTML into a document parser\n      const doc = new Doc(html);\n      const items = doc('div.last_episodes ul.items li');\n      \n      console.log(\"Found potential results:\", items.length());\n      \n      items.each((i, el) => {\n        const element = doc(el);\n        const link = element.find('p.name a');\n        const title = link.text().trim();\n        const url = link.attr('href');\n        const img = element.find('div.img img').attr('src');\n        \n        // Determine if it's sub or dub based on title\n        const isDub = title.toLowerCase().includes('(dub)');\n        \n        if (url) {\n          results.push({\n            id: url.replace(/^\\/+/, ''),  // Remove leading slashes\n            title: title,\n            url: this.api + url,\n            image: img,\n            subOrDub: isDub ? \"dub\" : \"sub\"\n          });\n        }\n      });\n      \n      console.log(\"Final results:\", results.length);\n      return results;\n    } catch (error) {\n      console.error(\"Search error:\", error);\n      return [];\n    }\n  }\n\n  async findEpisodes(id) {\n    console.log(\"Finding episodes for:\", id);\n    \n    try {\n      // Make sure the ID is in the correct format\n      if (id.startsWith('/')) {\n        id = id.substring(1);\n      }\n      \n      if (!id.startsWith('category/')) {\n        id = 'category/' + id;\n      }\n      \n      const url = `${this.api}/${id}`;\n      console.log(\"Fetching URL:\", url);\n      \n      const response = await fetch(url);\n      console.log(\"Response status:\", response.status);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch episodes: ${response.status}`);\n      }\n      \n      const html = await response.text();\n      console.log(\"HTML length:\", html.length);\n      \n      // Get anime ID for ajax request\n      const doc = new Doc(html);\n      const animeId = doc('input#movie_id').attr('value');\n      \n      if (!animeId) {\n        console.error(\"Could not find anime ID\");\n        return [];\n      }\n      \n      // Fetch episode list via ajax\n      const ajaxUrl = `${this.ajaxUrl}/load-list-episode?ep_start=0&ep_end=9999&id=${animeId}`;\n      console.log(\"Fetching episodes ajax URL:\", ajaxUrl);\n      \n      const ajaxResponse = await fetch(ajaxUrl);\n      const ajaxHtml = await ajaxResponse.text();\n      \n      const episodeDoc = new Doc(ajaxHtml);\n      const episodeItems = episodeDoc('ul#episode_related li a');\n      \n      const episodes = [];\n      \n      episodeItems.each((i, el) => {\n        const element = episodeDoc(el);\n        const episodeUrl = element.attr('href')?.trim();\n        const episodeNameFull = element.find('div.name').text().trim();\n        \n        // Extract episode number from the episode name\n        const epMatch = episodeNameFull.match(/EP\\s+(\\d+(\\.\\d+)?)/i);\n        let episodeNumber = i + 1;\n        \n        if (epMatch && epMatch[1]) {\n          episodeNumber = parseFloat(epMatch[1]);\n        }\n        \n        if (episodeUrl) {\n          episodes.push({\n            id: episodeUrl.replace(/^\\/+/, ''),\n            url: this.api + episodeUrl,\n            number: episodeNumber,\n            title: `Episode ${episodeNumber}`\n          });\n        }\n      });\n      \n      // Sort episodes by number\n      episodes.sort((a, b) => a.number - b.number);\n      \n      console.log(\"Final episode count:\", episodes.length);\n      return episodes;\n    } catch (error) {\n      console.error(\"Find episodes error:\", error);\n      return [];\n    }\n  }\n\n  async findEpisodeServer(episodeId, server = \"default\") {\n    console.log(\"Finding servers for episode:\", episodeId, \"server:\", server);\n    \n    try {\n      if (episodeId.startsWith('/')) {\n        episodeId = episodeId.substring(1);\n      }\n      \n      const url = `${this.api}/${episodeId}`;\n      console.log(\"Fetching URL:\", url);\n      \n      const response = await fetch(url);\n      console.log(\"Response status:\", response.status);\n      \n      if (!response.ok) {\n        throw new Error(`Failed to fetch episode: ${response.status}`);\n      }\n      \n      const html = await response.text();\n      console.log(\"HTML length:\", html.length);\n      \n      // Extract the streaming sources\n      const doc = new Doc(html);\n      \n      // Get the download link which contains the video ID\n      const downloadLink = doc('div.dowloads a').attr('href');\n      const videoIdMatch = html.match(/\\&id=([^&\"]*)/);\n      \n      if (!videoIdMatch || !videoIdMatch[1]) {\n        throw new Error(\"Could not find video ID\");\n      }\n      \n      const videoId = videoIdMatch[1];\n      console.log(\"Video ID:\", videoId);\n      \n      // Get available servers\n      const serverElements = doc('div.anime_muti_link ul li');\n      let targetServer = null;\n      \n      // Map the requested server to the site's server names\n      const serverMap = {\n        \"default\": \"vidcdn\",\n        \"vidstreaming\": \"vidcdn\",\n        \"streamsb\": \"streamsb\",\n        \"doodstream\": \"doodstream\"\n      };\n      \n      const requestedServerName = serverMap[server] || \"vidcdn\";\n      \n      // Find the requested server\n      serverElements.each((i, el) => {\n        const element = doc(el);\n        const serverClass = element.attr('class');\n        \n        if (serverClass && serverClass.includes(requestedServerName)) {\n          targetServer = element.data('video');\n          return false; // Break the loop\n        }\n      });\n      \n      if (!targetServer) {\n        // Fallback to the first server if requested one is not found\n        targetServer = doc('div.anime_muti_link ul li').first().data('video');\n      }\n      \n      if (!targetServer) {\n        throw new Error(\"No streaming servers found\");\n      }\n      \n      console.log(\"Found server:\", targetServer);\n      \n      // Use the server URL directly if it's a complete URL\n      let videoUrl = targetServer;\n      \n      // Some URLs need to be decoded or processed\n      if (videoUrl.startsWith('//')) {\n        videoUrl = 'https:' + videoUrl;\n      }\n      \n      // Determine the type of video\n      const isM3U8 = videoUrl.includes('.m3u8');\n      const isMp4 = videoUrl.includes('.mp4');\n      const type = isM3U8 ? 'm3u8' : (isMp4 ? 'mp4' : 'iframe');\n      \n      // For iframe sources, we need an extra step to extract the actual video URL\n      if (type === 'iframe') {\n        // This would require additional extraction steps in a real implementation\n        // For now, we'll return the iframe URL directly\n      }\n      \n      return {\n        server: server,\n        headers: {\n          \"Referer\": this.api,\n          \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36\"\n        },\n        videoSources: [{\n          url: videoUrl,\n          type: type,\n          quality: \"auto\",\n          subtitles: []\n        }]\n      };\n    } catch (error) {\n      console.error(\"Find episode server error:\", error);\n      return {\n        server: server,\n        headers: {},\n        videoSources: []\n      };\n    }\n  }\n}"
}
