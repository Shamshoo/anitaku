{
    "id": "anitaku-provider",
    "name": "Anitaku Streaming Provider",
    "description": "An online streaming provider extension for Anitaku",
    "manifestURI": "https://raw.githubusercontent.com/Shamshoo/anitaku/refs/heads/main/manifest.json",
    "version": "1.0.2",
    "author": "Shamshoo",
    "type": "onlinestream-provider",
    "language": "typescript",
    "lang": "en",
    "payload": "///<reference path=\"./onlinestream-provider.d.ts\"/>\n///<reference path=\"./doc.d.ts\"/>\n///<reference path=\"./crypto.d.ts\"/>\n\nclass Provider{\napi=\"https://anitaku.bz\"\najaxURL=\"https://ajax.gogocdn.net\"\n\ngetSettings():Settings{\nreturn{\nepisodeServers:[\"gogocdn\",\"vidstreaming\",\"streamsb\"],\nsupportsDub:true,\n}\n}\n\nasync search(opts:SearchOptions):Promise<SearchResult[]>{\nconst request=await fetch(`${this.api}/search.html?keyword=${encodeURIComponent(opts.query)}`)\nif(!request.ok){\nreturn[]\n}\nconst data=await request.text()\nconst results:SearchResult[]=[]\n\nconst $=LoadDoc(data)\n\n$(\"ul.items>li\").each((_,el)=>{\nconst title=el.find(\"p.name a\").text().trim()\nconst id=el.find(\"div.img a\").attr(\"href\")\nif(!id){\nreturn\n}\n\nresults.push({\nid:id,\ntitle:title,\nurl:id,\nsubOrDub:\"sub\",\n})\n})\n\nreturn results\n}\n\nasync findEpisodes(id:string):Promise<EpisodeDetails[]>{\nconst episodes:EpisodeDetails[]=[]\n\nconst data=await(await fetch(`${this.api}${id}`)).text()\n\nconst $=LoadDoc(data)\n\nconst epStart=$(\"#episode_page>li\").first().find(\"a\").attr(\"ep_start\")\nconst epEnd=$(\"#episode_page>li\").last().find(\"a\").attr(\"ep_end\")\nconst movieId=$(\"#movie_id\").attr(\"value\")\nconst alias=$(\"#alias_anime\").attr(\"value\")\n\nconst req=await(await fetch(`${this.ajaxURL}/ajax/load-list-episode?ep_start=${epStart}&ep_end=${epEnd}&id=${movieId}&default_ep=${0}&alias=${alias}`)).text()\n\nconst $$=LoadDoc(req)\n\n$$(\"#episode_related>li\").each((i,el)=>{\nepisodes?.push({\nid:el.find(\"a\").attr(\"href\")?.trim()??\"\",\nurl:el.find(\"a\").attr(\"href\")?.trim()??\"\",\nnumber:parseFloat(el.find(`div.name`).text().replace(\"EP \",\"\")),\ntitle:el.find(`div.name`).text(),\n})\n})\n\nreturn episodes.reverse()\n}\n\nasync findEpisodeServer(episode:EpisodeDetails,_server:string):Promise<EpisodeServer>{\nlet server=\"gogocdn\"\nif(_server!==\"default\"){\nserver=_server\n}\n\nconst episodeServer:EpisodeServer={\nserver:server,\nheaders:{},\nvideoSources:[],\n}\n\nif(episode.id.startsWith(\"http\")){\nconst serverURL=episode.id\ntry{\nconst es=await new Extractor(serverURL,episodeServer).extract(server)\nif(es){\nreturn es\n}\n}\ncatch(e){\nconsole.error(e)\nreturn episodeServer\n}\nreturn episodeServer\n}\n\nconst data=await(await fetch(`${this.api}${episode.id}`)).text()\n\nconst $=LoadDoc(data)\n\nlet serverURL:string\n\nswitch(server){\ncase\"gogocdn\":\nserverURL=`${$(\"#load_anime>div>div>iframe\").attr(\"src\")}`\nbreak\ncase\"vidstreaming\":\nserverURL=`${$(\"div.anime_video_body>div.anime_muti_link>ul>li.vidcdn>a\").attr(\"data-video\")}`\nbreak\ncase\"streamsb\":\nserverURL=$(\"div.anime_video_body>div.anime_muti_link>ul>li.streamsb>a\").attr(\"data-video\")!\nbreak\ndefault:\nserverURL=`${$(\"#load_anime>div>div>iframe\").attr(\"src\")}`\nbreak\n}\n\nepisode.id=serverURL\nreturn await this.findEpisodeServer(episode,server)\n}\n}\n\nclass Extractor{\nprivate url:string\nprivate result:EpisodeServer\n\nconstructor(url:string,result:EpisodeServer){\nthis.url=url\nthis.result=result\n}\n\nasync extract(server:string):Promise<EpisodeServer|undefined>{\ntry{\nswitch(server){\ncase\"gogocdn\":\nconsole.log(\"GogoCDN extraction\")\nreturn await this.extractGogoCDN(this.url,this.result)\ncase\"vidstreaming\":\nreturn await this.extractGogoCDN(this.url,this.result)\ndefault:\nreturn undefined\n}\n}\ncatch(e){\nconsole.error(e)\nreturn undefined\n}\n}\n\npublic async extractGogoCDN(url:string,result:EpisodeServer):Promise<EpisodeServer>{\nconst keys={\nkey:CryptoJS.enc.Utf8.parse(\"37911490979715163134003223491201\"),\nsecondKey:CryptoJS.enc.Utf8.parse(\"54674138327930866480207815084989\"),\niv:CryptoJS.enc.Utf8.parse(\"3134003223491201\"),\n}\n\nfunction generateEncryptedAjaxParams(id:string){\nconst encryptedKey=CryptoJS.AES.encrypt(id,keys.key,{\niv:keys.iv,\n})\n\nconst scriptValue=$(\"script[data-name='episode']\").data(\"value\")!\n\nconst decryptedToken=CryptoJS.AES.decrypt(scriptValue,keys.key,{\niv:keys.iv,\n}).toString(CryptoJS.enc.Utf8)\n\nreturn`id=${encryptedKey.toString(CryptoJS.enc.Base64)}&alias=${id}&${decryptedToken}`\n}\n\nfunction decryptAjaxData(encryptedData:string){\nconst decryptedData=CryptoJS.AES.decrypt(encryptedData,keys.secondKey,{\niv:keys.iv,\n}).toString(CryptoJS.enc.Utf8)\n\nreturn JSON.parse(decryptedData)\n}\n\nconst req=await fetch(url)\n\nconst $=LoadDoc(await req.text())\n\nconst encryptedParams=generateEncryptedAjaxParams(new URL(url).searchParams.get(\"id\")??\"\"))\n\nconst xmlHttpUrl=`${new URL(url).protocol}//${new URL(url).hostname}/encrypt-ajax.php?${encryptedParams}`\n\nconst encryptedData=await fetch(xmlHttpUrl,{\nheaders:{\n\"X-Requested-With\":\"XMLHttpRequest\",\n},\n})\n\nconst decryptedData=await decryptAjaxData(((await encryptedData.json())as{data:any})?.data)\nif(!decryptedData.source)throw new Error(\"No source found. Try a different server.\")\n\nif(decryptedData.source[0].file.includes(\".m3u8\")){\nconst resResult=await fetch(decryptedData.source[0].file.toString())\nconst resolutions=(await resResult.text()).match(/(RESOLUTION=)(.*)(\s*?)(\s*.*)/g)\n\nresolutions?.forEach((res:string)=>{\nconst index=decryptedData.source[0].file.lastIndexOf(\"/\")\nconst quality=res.split(\"\\n\")[0].split(\"x\")[1].split(\",\")[0]\nconst url=decryptedData.source[0].file.slice(0,index)\n\nresult.videoSources.push({\nurl:url+\"/\"+res.split(\"\\n\")[1],\nquality:quality+\"p\",\nsubtitles:[],\ntype:\"m3u8\",\n})\n})\n\ndecryptedData.source.forEach((source:any)=>{\nresult.videoSources.push({\nurl:source.file,\nquality:\"default\",\nsubtitles:[],\ntype:\"m3u8\",\n})\n})\n}else{\ndecryptedData.source.forEach((source:any)=>{\nresult.videoSources.push({\nurl:source.file,\nquality:source.label.split(\" \")[0]+\"p\",\nsubtitles:[],\ntype:\"m3u8\",\n})\n})\n\ndecryptedData.source_bk.forEach((source:any)=>{\nresult.videoSources.push({\nurl:source.file,\nquality:\"backup\",\nsubtitles:[],\ntype:\"m3u8\",\n})\n})\n}\n\nreturn result\n}\n}"
}
